<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sarah Zendle Final Project</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="./resources/css/style.css">

    <!-- MathJax mathematical expression library -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body onload="webGLStart()" onresize="canvas.resize();">

    <div class="row">
      <div id="canvas_container">
        <canvas id="canvas" width="100%" height="100%"></canvas>
      </div>
      <div style="position: absolute" class="row" id="content_container">
        <h1>PlotComplex</h1>
        <div class="col-3" style="padding: 2.5%">
            <!-- FUNCTION INPUT -->
            <!-- show current input function -->
            <div id="eqn-pretty">\[z^2\]</div>
              <br>
            <!-- equation input -->
            <label for="eqn">f(z) = </label> 
            <input id="eqn" type="text" onkeyup="parseEQ()" placeholder="z^2">
            <br>
            <div id="error" style="color: red"></div>
            <br>
            <button class="btn btn-primary" id="graph-it">Graph It!</button>
        </div>
        <div class="col-7">
            <!-- MAIN WEBGL DISPLAY -->
            <canvas id="canvas"></canvas>
        </div>
        <div class="col-2" style="padding: 2.5%">
            <!-- TOGGLES AND DISPLAY SETTINGS -->
            <input type="radio" id="sphere" name="fav_language" value="sphere" checked="true">
            <label for="html">Sphere</label><br>
            <input type="radio" id="surface" name="fav_language" value="surface">
            <label for="css">Surface</label><br>
        </div>
      </div>
        
    </div>

    <!-- WEBGL SHADERS -->

    <!--
    Sphere Vertex shader
    -->
    <script id="sphere-vs" type="x-shader/x-vertex"> 
      precision highp float;
      //  Transformation matrices
      uniform mat4 ProjectionMatrix;
      uniform mat4 ViewMatrix;
      uniform mat4 ModelViewMatrix;
      uniform mat3 NormalMatrix;

      //  Light propeties
      uniform float fov;
      uniform vec4 Global;
      uniform vec4 Ambient;
      uniform vec4 Diffuse;
      uniform vec4 Specular;
      uniform vec4 Position;

      //  Vertex attributes (input)
      attribute vec4 Vertex;
      attribute vec3 Normal;
      attribute vec4 Color;

      //  Output to next shader
      varying vec4 LightIntensity;
      varying vec4 fColor;
      varying vec4 fPosition;

      vec4 phong(){
        //  P is the vertex coordinate on body
        vec3 P = vec3(ModelViewMatrix * Vertex);
        //  N is the object normal at P
        vec3 N = normalize(NormalMatrix * Normal);
        //  L is the light vector
        vec3 L = normalize(vec3(ViewMatrix*Position) - P);

        //  Emission and ambient color
        vec4 color = (Global+Ambient);

        //  Diffuse light intensity is cosine of light and normal vectors
        float Id = dot(L,N);
        if (Id>0.0)
        {
            //  Add diffuse - material color from Color
            color += Id*Diffuse;
            //  R is the reflected light vector R = 2(L.N)N - L
            vec3 R = reflect(-L, N);
            //  V is the view vector (eye at the origin)
            vec3 V = (fov>0.0) ? normalize(-P) : vec3(0,0,1);
            //  Specular is cosine of reflected and view vectors
            //  Assert material specular color is white
            float Is = dot(R,V);
            if (Is>0.0) color += pow(Is,16.0)*Specular;
        }

        //  Return sum of color components
        return color;
      }

      void main(void)
      {
        gl_Position = ProjectionMatrix * ModelViewMatrix * Vertex;
        LightIntensity = phong();
        fColor = Color;
        fPosition = Vertex;
      }
    </script> 
  
    <!--
    Fragment shader
    -->
    <script id="sphere-fs" type="x-shader/x-fragment"> 
      precision highp float;
      //  Vertex attributes (input)
      varying vec4 fColor;
      varying vec4 LightIntensity;
      varying vec4 fPosition;

      uniform float function[20];

      //------GLOBALS------//
      // really big floats are reserved for functions and operators
      const float Z = 3.4028234663852886e+38;
      const float MULT = 3.4028232635611926e+38;
      const float DIV = 3.4028230607370965e+38;
      const float ADD = 3.4028228579130005e+38;
      const float SUB = 3.4028226550889045e+38;
      const float POW = 3.4028220466166163e+38;
      const float SIN = 3.4028218437925203e+38;
      const float COS = 3.4028216409684243e+38;
      const float TAN = 3.4028214381443282e+38;
      const float EXP = 3.40282082967204e+38;
      const float ERR = 3.402820424023848e+38;
      const float END = 3.402820626847944e+38;

      const int N = 20;

      //argument "stack" variables
      vec2 asp0 = vec2(0.0, -1.0);
      vec2 asp1 = vec2(0.0, -1.0);
      vec2 asp2 = vec2(0.0, -1.0);
      vec2 asp3 = vec2(0.0, -1.0);
      vec2 asp4 = vec2(0.0, -1.0);
      vec2 asp5 = vec2(0.0, -1.0);
      vec2 asp6 = vec2(0.0, -1.0);
      

      //------HELPERS------//
      //convert complex number z from cartesian to polar (x + iy --> r*e^i(th))
      vec2 rth(vec2 z) {
        float r = sqrt(z.x*z.x + z.y*z.y);
        float th = atan(z.y/z.x);
        if(z.x < 0.0) th += 3.141592653;
        else if(th < 0.0) th += 6.2831853;
        return vec2 (r, th);
      }

      //convert complex number z from polar to cartesian (r*e^i(th) --> x + iy)
      vec2 xy(vec2 z) {
        float x = z.x * cos(z.y);
        float y = z.x * sin(z.y);
        return vec2(x, y);
      }

      //the most convoluted stack implementation in existence
      int push_arg(vec2 val, int asp) {
        if(asp > 6) return asp;//THIS COULD BE A PROBLEM SPOT
        if(asp==0) asp0 = val;
        else if(asp==1) asp1 = val;
        else if(asp==2) asp2 = val;
        else if(asp==3) asp3 = val;
        else if(asp==4) asp4 = val;
        else if(asp==5) asp5 = val;
        else if(asp==6) asp6 = val;
        return asp + 1;
      }

      vec2 pop_arg(int asp) {
        if(asp < 1 || asp > 7) return vec2(0, -1);//THIS TOO
        else if(asp==1) return asp0;
        else if(asp==2) return asp1;
        else if(asp==3) return asp2;
        else if(asp==4) return asp3;
        else if(asp==5) return asp4;
        else if(asp==6) return asp5;
        else if(asp==7) return asp6;
      }

      float sinh(float x) {
        return 0.5*(exp(x)-exp(-x));
      }
      float cosh(float x) {
        return 0.5*(exp(x)+exp(-x));
      }

      //----OPERATIONS-----//

      //MULT
      vec2 Mult(vec2 z1, vec2 z2) {
        float u = z1.x*z2.x - z1.y*z2.y;
        float v = z1.y*z2.x + z1.x*z2.y;
        return vec2(u,v);
      }

      //DIV
      vec2 Div(vec2 z1, vec2 z2) {
        z1 = rth(z1);
        z2 = rth(z2);
        return xy(vec2(z1.x/z2.x, z1.y - z2.y));
      }

      //ADD
      vec2 Add(vec2 z1, vec2 z2) {
        return vec2(z1.x + z2.x, z1.y + z2.y);
      }

      //SUB
      vec2 Sub(vec2 z1, vec2 z2) {
        return Add(z1, z2*-1.0);
      }
      
      //EXP f(z) = e^z
      vec2 Exp(vec2 z) {
        float ex = exp(z.x);
        float u = ex * cos(z.y);
        float v = ex * sin(z.y);
        return vec2 (u, v);
      }

      //POW f(z) = z^n
      vec2 Pow(vec2 z, float n) {
        z = rth(z);
        float r = pow(z.x, n);
        float th = z.y * n;
        return xy(vec2(r, th));
      }

      //SIN f(z) = sin(z)
      vec2 Sin(vec2 z) {
        return vec2(cosh(z.y)*sin(z.x), sinh(z.y)*cos(z.x));
      }

      //COS f(z) = cos(z)
      vec2 Cos(vec2 z) {
        return vec2(cosh(z.y)*cos(z.x), sinh(z.y)*sin(z.x));
      }

      //TAN f(z) = tan(z)
      vec2 Tan(vec2 z) {
        return Div(Sin(z),Cos(z));
      }

      //f(z) = z* (complex conjugate)
      vec2 conjugate(vec2 z) {
        return vec2(z.x, -z.y);
      }

      //-----READ FUNCTION-------//

      //parse RPN in uniforms and apply operations to z-value at this fragment
      vec2 parseRPN(vec2 z) {
        int argsp = 0;
        vec2 argument1 = vec2(0,-1.0);
        for (int i = 0; i < N; i++) {
          if(function[i] == END) break;

          if(function[i] < ERR) {//not END, ERR, Z, or an operator, so must be an argument
            push_arg(vec2(function[i],0),argsp);//assuming no complex number constants
            argsp++;
          }
          else if(function[i] == Z) {
            push_arg(z, argsp);
            argsp++;
          }
          else if(function[i] == ERR) {
            return vec2(-1,0);//an unexpectedly high amount of cyan indicates an error in tree traversing
          }
          else if(function[i] == MULT) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Mult(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == DIV) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Div(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == ADD) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Add(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == SUB) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Sub(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == POW) {
            argument1 = pop_arg(argsp);
            argsp--;
            if(argument1 == z) return vec2(0,1);//lots of green indicates a POW we can't evaluate
            else push_arg(Pow(z, argument1.x),argsp-1);
            argsp--;
           }
           else if(function[i] == SIN) {
            push_arg (Sin(pop_arg(argsp)),argsp-1);
           }
           else if(function[i] == COS) {
            push_arg (Cos(pop_arg(argsp)),argsp-1);
           }
           else if(function[i] == TAN) {
             push_arg (Tan(pop_arg(argsp)),argsp-1);
           }
           else if(function[i] == EXP) {
            push_arg (Exp(pop_arg(argsp)),argsp-1);
           }
        }
        return asp0;
      }

      //from https://www.shadertoy.com/view/XljGzV
      vec3 hsl2rgb( vec3 c )
      {
          vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

          return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
      }

      //map phase to hue and magnitude to lightness (lighter = bigger)
      vec3 color_cmplx(vec2 z) {
        float h = atan(z.y, z.x);//calculate angle
        h =  h / 6.283185307;
        float l = sqrt(z.x*z.x + z.y*z.y);//calculate magnitude
        l = l/(1.0+l);//continuously map magnitude to [0, 1]
        return hsl2rgb(vec3(h, 1,l));
      }

      //maps vector on sphere to corresponding stereographic projection vector on plane
      vec2 projection(vec3 p) {
        float u = (2.0*p.x) / (2.0 - p.y);
        float v = (2.0*p.z) / (2.0 - p.y);
        return vec2(u, v);
      }

      void main()
      {
        vec2 z = projection(vec3(fPosition.x, fPosition.y + 1.0, fPosition.z));
        z = parseRPN(z);
        gl_FragColor = vec4(color_cmplx(z),1) * LightIntensity;
      }
    </script> 

    <!--
    Surface Vertex shader
    -->
    <script id="surface-vs" type="x-shader/x-vertex"> 
      precision highp float;
      //  Transformation matrices
      uniform mat4 ProjectionMatrix;
      uniform mat4 ViewMatrix;
      uniform mat4 ModelViewMatrix;
      uniform mat3 NormalMatrix;

      //  Light propeties
      uniform float fov;
      uniform vec4 Global;
      uniform vec4 Ambient;
      uniform vec4 Diffuse;
      uniform vec4 Specular;
      uniform vec4 Position;

      //  Vertex attributes (input)
      attribute vec4 Vertex;
      attribute vec3 Normal;
      attribute vec4 Color;

      //  Output to next shader
      varying vec4 LightIntensity;
      varying vec4 fColor;
      varying vec4 fPosition;

      uniform float function[20];

      //------GLOBALS------//
      // really big floats are reserved for functions and operators
      const float Z = 3.4028234663852886e+38;
      const float MULT = 3.4028232635611926e+38;
      const float DIV = 3.4028230607370965e+38;
      const float ADD = 3.4028228579130005e+38;
      const float SUB = 3.4028226550889045e+38;
      const float POW = 3.4028220466166163e+38;
      const float SIN = 3.4028218437925203e+38;
      const float COS = 3.4028216409684243e+38;
      const float TAN = 3.4028214381443282e+38;
      const float EXP = 3.40282082967204e+38;
      const float ERR = 3.402820424023848e+38;
      const float END = 3.402820626847944e+38;

      const int N = 20;

      //argument "stack" variables
      vec2 asp0 = vec2(0.0, -1.0);
      vec2 asp1 = vec2(0.0, -1.0);
      vec2 asp2 = vec2(0.0, -1.0);
      vec2 asp3 = vec2(0.0, -1.0);
      vec2 asp4 = vec2(0.0, -1.0);
      vec2 asp5 = vec2(0.0, -1.0);
      vec2 asp6 = vec2(0.0, -1.0);
      
      vec3 newNorm;

      //------HELPERS------//
      //convert complex number z from cartesian to polar (x + iy --> r*e^i(th))
      vec2 rth(vec2 z) {
        float r = sqrt(z.x*z.x + z.y*z.y);
        float th = atan(z.y/z.x);
        if(z.x < 0.0) th += 3.141592653;
        else if(th < 0.0) th += 6.2831853;
        return vec2 (r, th);
      }

      //convert complex number z from polar to cartesian (r*e^i(th) --> x + iy)
      vec2 xy(vec2 z) {
        float x = z.x * cos(z.y);
        float y = z.x * sin(z.y);
        return vec2(x, y);
      }

      //the most convoluted stack implementation in existence
      int push_arg(vec2 val, int asp) {
        if(asp > 6) return asp;//THIS COULD BE A PROBLEM SPOT
        if(asp==0) asp0 = val;
        else if(asp==1) asp1 = val;
        else if(asp==2) asp2 = val;
        else if(asp==3) asp3 = val;
        else if(asp==4) asp4 = val;
        else if(asp==5) asp5 = val;
        else if(asp==6) asp6 = val;
        return asp + 1;
      }

      vec2 pop_arg(int asp) {
        if(asp < 1 || asp > 7) return vec2(0, -1);//THIS TOO
        else if(asp==1) return asp0;
        else if(asp==2) return asp1;
        else if(asp==3) return asp2;
        else if(asp==4) return asp3;
        else if(asp==5) return asp4;
        else if(asp==6) return asp5;
        else if(asp==7) return asp6;
      }

      float sinh(float x) {
        return 0.5*(exp(x)-exp(-x));
      }
      float cosh(float x) {
        return 0.5*(exp(x)+exp(-x));
      }

      //----OPERATIONS-----//

      //MULT
      vec2 Mult(vec2 z1, vec2 z2) {
        float u = z1.x*z2.x - z1.y*z2.y;
        float v = z1.y*z2.x + z1.x*z2.y;
        return vec2(u,v);
      }

      //DIV
      vec2 Div(vec2 z1, vec2 z2) {
        z1 = rth(z1);
        z2 = rth(z2);
        return xy(vec2(z1.x/z2.x, z1.y - z2.y));
      }

      //ADD
      vec2 Add(vec2 z1, vec2 z2) {
        return vec2(z1.x + z2.x, z1.y + z2.y);
      }

      //SUB
      vec2 Sub(vec2 z1, vec2 z2) {
        return Add(z1, z2*-1.0);
      }
      
      //EXP f(z) = e^z
      vec2 Exp(vec2 z) {
        float ex = exp(z.x);
        float u = ex * cos(z.y);
        float v = ex * sin(z.y);
        return vec2 (u, v);
      }

      //POW f(z) = z^n
      vec2 Pow(vec2 z, float n) {
        z = rth(z);
        float r = pow(z.x, n);
        float th = z.y * n;
        return xy(vec2(r, th));
      }

      //SIN f(z) = sin(z)
      vec2 Sin(vec2 z) {
        return vec2(cosh(z.y)*sin(z.x), sinh(z.y)*cos(z.x));
      }

      //COS f(z) = cos(z)
      vec2 Cos(vec2 z) {
        return vec2(cosh(z.y)*cos(z.x), sinh(z.y)*sin(z.x));
      }

      //TAN f(z) = tan(z)
      vec2 Tan(vec2 z) {
        return Div(Sin(z),Cos(z));
      }

      //f(z) = z* (complex conjugate)
      vec2 conjugate(vec2 z) {
        return vec2(z.x, -z.y);
      }

      //-----READ FUNCTION-------//

      //parse RPN in uniforms and apply operations to z-value at this fragment
      vec2 parseRPN(vec2 z) {
        int argsp = 0;
        vec2 argument1 = vec2(0,-1.0);
        for (int i = 0; i < N; i++) {
          if(function[i] == END) break;

          if(function[i] < ERR) {//not END, ERR, Z, or an operator, so must be an argument
            push_arg(vec2(function[i],0),argsp);//assuming no complex number constants
            argsp++;
          }
          else if(function[i] == Z) {
            push_arg(z, argsp);
            argsp++;
          }
          else if(function[i] == ERR) {
            return vec2(-1,0);//an unexpectedly high amount of cyan indicates an error in tree traversing
          }
          else if(function[i] == MULT) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Mult(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == DIV) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Div(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == ADD) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Add(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == SUB) {
            argument1 = pop_arg(argsp);
            argsp--;
            push_arg(Sub(pop_arg(argsp), argument1),argsp-1);
          }
          else if(function[i] == POW) {
            argument1 = pop_arg(argsp);
            argsp--;
            if(argument1 == z) return vec2(0,1);//lots of green indicates a POW we can't evaluate
            else push_arg(Pow(z, argument1.x),argsp-1);
            argsp--;
           }
           else if(function[i] == SIN) {
            push_arg (Sin(pop_arg(argsp)),argsp-1);
           }
           else if(function[i] == COS) {
            push_arg (Cos(pop_arg(argsp)),argsp-1);
           }
           else if(function[i] == TAN) {
             push_arg (Tan(pop_arg(argsp)),argsp-1);
           }
           else if(function[i] == EXP) {
            push_arg (Exp(pop_arg(argsp)),argsp-1);
           }
        }
        return asp0;
      }

      vec4 phong(){
        //  P is the vertex coordinate on body
        vec3 P = vec3(ModelViewMatrix * Vertex);
        //  N is the object normal at P
        vec3 N = normalize(NormalMatrix * Normal);
        //  L is the light vector
        vec3 L = normalize(vec3(ViewMatrix*Position) - P);

        //  Emission and ambient color
        vec4 color = (Global+Ambient);

        //  Diffuse light intensity is cosine of light and normal vectors
        float Id = dot(L,N);
        if (Id>0.0)
        {
            //  Add diffuse - material color from Color
            color += Id*Diffuse;
            //  R is the reflected light vector R = 2(L.N)N - L
            vec3 R = reflect(-L, N);
            //  V is the view vector (eye at the origin)
            vec3 V = (fov>0.0) ? normalize(-P) : vec3(0,0,1);
            //  Specular is cosine of reflected and view vectors
            //  Assert material specular color is white
            float Is = dot(R,V);
            if (Is>0.0) color += pow(Is,16.0)*Specular;
        }

        //  Return sum of color components
        return color;
      }

      void main(void)
      {
        vec2 z = parseRPN(vec2(Vertex.x, Vertex.z));
        vec4 newPos = vec4(Vertex.x, rth(z).x/10.0, Vertex.z, Vertex.w);
        //vec3 newNorm = cross(newPos.xyz, vec3(Vertex.x + 1.0/24.0, rth(vec2(z.x+1.0/24.0,z.y)).x/50.0, Vertex.z));
        gl_Position = ProjectionMatrix * ModelViewMatrix * newPos;
        LightIntensity = phong();
        fColor = Color;
        fPosition = Vertex;
      }
    </script> 

    <!-- SCRIPTS -->
    <script src="resources/js/math.js"></script>
    <script src="resources/js/mat4.js"></script>
    <script src="resources/js/globals.js"></script>
    <script src="resources/js/parse.js"></script>
    <script src="resources/js/plot.js"></script>

  </body>
</html>
